<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Web Bridge RT Messaging</title>
  <script src="https://cdn.jsdelivr.net/npm/backendless@7/dist/backendless.min.js"></script>
</head>
<body>
  <h2>Messaging Bridge Active</h2>

  <script>
    // Backendless configuration
    const APP_ID = "9561383D-4BC2-F4F1-FF73-B529BFE77000";
    const API_KEY_SUBSCRIBE = "BEE4A193-7ADC-419B-9EB4-202FDA99ACC6"; // Read-only key
    const API_KEY_PUBLISH = "4CD13851-2D6E-44B6-BB66-5437FCBF0B8C"; // Publish key

    // Handle incoming messages from Thunkable
    window.addEventListener("message", async (event) => {
      let data;
      try {
        // Parse event.data if string, otherwise use directly
        data = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
      } catch (e) {
        console.error("‚ùå Invalid message format:", e.message);
        return;
      }

      // Validate required fields
      if (!data || !data.mode || !data.token) {
        console.warn("‚ùå Missing required data: mode or token");
        return;
      }

      const mode = data.mode;
      const token = data.token;

      if (mode === "listen") {
        // Validate channelName for listen mode
        const channelName = data.channelName;
        if (!channelName) {
          console.warn("‚ùå Missing channelName for listen mode");
          return;
        }

        // Initialize Backendless for subscription
        Backendless.initApp(APP_ID, API_KEY_SUBSCRIBE);
        Backendless.UserService.setCurrentUserToken(token);

        try {
          const channel = Backendless.Messaging.subscribe(channelName);
          channel.addMessageListener((message) => {
            // Ensure message is stringified for Thunkable WebView
            const msgText = typeof message === "object" ? JSON.stringify(message) : message;
            if (window.ReactNativeWebView?.postMessage) {
              window.ReactNativeWebView.postMessage(msgText);
            }
          });
          console.log("‚úÖ Listening on channel:", channelName);
        } catch (e) {
          console.error("‚ùå Subscription error:", e.message);
        }
      } else if (mode === "publish") {
        // Derive channel from token
        let channelName;
        try {
          const parsedToken = JSON.parse(atob(token.split('.')[1]));
          const objectId = parsedToken['objectId'] || parsedToken['user-id'];
          if (!objectId) throw new Error("Invalid objectId in token");
          channelName = objectId.substring(0, 6);
        } catch (e) {
          console.error("‚ùå Failed to derive channel from token:", e.message);
          return;
        }

        // Initialize Backendless for publishing
        Backendless.initApp(APP_ID, API_KEY_PUBLISH);
        Backendless.UserService.setCurrentUserToken(token);

        // Construct payload
        const payload = {
          latestOb: data.latestOb || null,
          location: data.location || null,
          timestamp: new Date().toISOString()
        };

        try {
          await Backendless.Messaging.publish(channelName, payload, {
            headers: { "user-token": token }
          });
          console.log("üì§ Message published to", channelName);
        } catch (e) {
          console.error("‚ùå Failed to publish:", e.message);
        }
      } else {
        console.warn("‚ùå Invalid mode:", mode);
      }
    });

    console.log("üì° Web Bridge ready to receive instructions from Thunkable...");
  </script>
</body>
</html>
