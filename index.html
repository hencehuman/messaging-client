<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Web Bridge RT Messaging</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.jsdelivr.net; connect-src *; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline';">
  <meta http-equiv="Access-Control-Allow-Origin" content="*">
  <script src="https://cdn.jsdelivr.net/npm/backendless@7/dist/backendless.min.js"></script>
</head>
<body>
  <h2>Messaging Bridge Active</h2>

  <script>
    // Backendless configuration
    const APP_ID = "9561383D-4BC2-F4F1-FF73-B529BFE77000";
    const API_KEY_SUBSCRIBE = "BEE4A193-7ADC-419B-9EB4-202FDA99ACC6";
    const API_KEY_PUBLISH = "4CD13851-2D6E-44B6-BB66-5437FCBF0B8C";

    // Expose handleMessage globally for evaluateJavascript
    window.handleMessage = async function(event) {
      let data = event.data || event; // Handle direct calls from evaluateJavascript
      console.log("ğŸ“¥ Raw message received:", data, "Origin:", event.origin || "direct", "Source:", event.source || "none");
      try {
        if (data === null || data === undefined) {
          throw new Error("Empty or undefined message data");
        }
        if (typeof data === "string") {
          data = data.trim() ? JSON.parse(data) : {};
        } else if (typeof data !== "object" || data === null) {
          throw new Error("Unsupported data type");
        }
        console.log("ğŸ“¦ Parsed message:", JSON.stringify(data));
      } catch (e) {
        console.error("âŒ Invalid message format:", e.message, "Raw data:", data);
        return;
      }

      if (!data || !data.mode || !data.token) {
        console.warn("âŒ Missing required data: mode or token", data);
        return;
      }

      const mode = data.mode;
      const token = data.token;

      if (mode === "listen") {
        const channelName = data.channelName;
        if (!channelName) {
          console.warn("âŒ Missing channelName for listen mode");
          return;
        }

        Backendless.initApp(APP_ID, API_KEY_SUBSCRIBE);
        Backendless.UserService.setCurrentUserToken(token);

        try {
          const channel = Backendless.Messaging.subscribe(channelName);
          channel.addMessageListener((message) => {
            const msgText = typeof message === "object" ? JSON.stringify(message) : message;
            console.log("ğŸ“¤ Sending to WebView:", msgText);
            try {
              // Multiple postMessage targets
              if (window.ReactNativeWebView?.postMessage) {
                window.ReactNativeWebView.postMessage(msgText);
              }
              if (window.Android?.postMessage) {
                window.Android.postMessage(msgText);
              }
              if (window.webkit?.messageHandlers?.webview) {
                window.webkit.messageHandlers.webview.postMessage(msgText);
              }
              if (window.chrome?.webview) {
                window.chrome.webview.postMessage(msgText);
              }
              window.parent.postMessage(msgText, "*");
              window.postMessage(msgText, "*");
              // Custom event fallback
              const event = new CustomEvent("message", { detail: msgText });
              document.dispatchEvent(event);
            } catch (e) {
              console.error("âŒ Failed to post message to WebView:", e.message);
            }
          });
          console.log("âœ… Listening on channel:", channelName);
        } catch (e) {
          console.error("âŒ Subscription error:", e.message);
        }
      } else if (mode === "publish") {
        let channelName;
        try {
          const parsedToken = JSON.parse(atob(token.split('.')[1]));
          console.log("ğŸ” Parsed token payload:", JSON.stringify(parsedToken));
          const objectId = parsedToken['objectId'] || parsedToken['user-id'] || parsedToken['userId'] || parsedToken['id'] || parsedToken['sub'];
          if (!objectId) throw new Error("No valid user identifier (objectId, user-id, userId, id, sub) in token");
          channelName = objectId.substring(0, 6);
          console.log("ğŸ“Œ Derived channelName:", channelName);
        } catch (e) {
          console.error("âŒ Failed to derive channel from token:", e.message, "Token:", token);
          return;
        }

        Backendless.initApp(APP_ID, API_KEY_PUBLISH);
        Backendless.UserService.setCurrentUserToken(token);

        const payload = {
          latestOb: data.latestOb || null,
          location: data.location || null,
          timestamp: new Date().toISOString()
        };
        console.log("ğŸ“¦ Publish payload:", JSON.stringify(payload));

        try {
          await Backendless.Messaging.publish(channelName, payload);
          console.log("ğŸ“¤ Message published to", channelName);
        } catch (e) {
          console.error("âŒ Failed to publish:", e.message, e);
        }
      } else {
        console.warn("âŒ Invalid mode:", mode);
      }
    };

    // Attach multiple listeners
    window.addEventListener("message", window.handleMessage);
    window.parent.addEventListener("message", window.handleMessage);
    window.top.addEventListener("message", window.handleMessage);
    window.onmessage = window.handleMessage;
    // Custom event listener for Android
    document.addEventListener("message", (event) => {
      console.log("ğŸ“¥ Custom event received:", event.detail);
      window.handleMessage({ data: event.detail, origin: "custom", source: "document" });
    });

    console.log("ğŸ“¡ Web Bridge ready to receive instructions from Thunkable...");
  </script>
</body>
</html>
